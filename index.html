<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Tyler City Traffic Dashboard Simulation</title>
<!-- Leaflet CSS -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<style>
  body, html { margin:0; padding:0; height:100%; font-family: Arial, sans-serif; }
  #map { position:absolute; top:0; bottom:0; left:250px; right:250px; }
  .panel { position:absolute; top:0; bottom:0; width:250px; overflow-y:auto; padding:10px; background:#0b1220; color:#fff; font-size:14px; }
  #leftPanel { left:0; border-right: 1px solid #222; }
  #rightPanel { right:0; border-left: 1px solid #222; }
  h2 { margin-top:10px; font-size:16px; border-bottom:1px solid #444; padding-bottom:5px; }
  .kpi { margin:5px 0; }
  .report { margin:5px 0; padding:5px; background:#111; border-radius:5px; }
  button { margin:3px; padding:4px 8px; border:none; border-radius:4px; cursor:pointer; background:#00c2ff; color:#0b1220; }
</style>
</head>
<body>

<!-- Left Panel: KPIs + Department Filter -->
<div id="leftPanel" class="panel">
  <h2>KPIs</h2>
  <div class="kpi">Average Speed: <span id="avgSpeed">--</span></div>
  <div class="kpi">Congested Segments: <span id="congested">--</span></div>
  <div class="kpi">Travel Time Index: <span id="tti">--</span></div>
  <div class="kpi">Active Alerts: <span id="alerts">--</span></div>

  <h2>Department Filter</h2>
  <div id="departmentButtons"></div>
</div>

<!-- Right Panel: Situation Reports -->
<div id="rightPanel" class="panel">
  <h2>Situation Reports</h2>
  <div id="reports"></div>
</div>

<!-- Map -->
<div id="map"></div>

<!-- Leaflet JS -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
// ---------------- BASE MAP ----------------
const map = L.map('map').setView([32.351,-95.301], 13); // Centered on Tyler, TX

// Add base tile layer (OpenStreetMap)
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  attribution: '&copy; OpenStreetMap contributors'
}).addTo(map);

// ---------------- DEPARTMENT BUTTONS ----------------
const departments = ["All", "Police","Fire","Traffic","Streets","Engineering"];
const deptDiv = document.getElementById('departmentButtons');
departments.forEach(dept => {
  const btn = document.createElement('button');
  btn.innerText = dept;
  btn.onclick = () => {
    alert("Department filter clicked: " + dept + "\n(Will filter traffic simulation in next steps)");
  };
  deptDiv.appendChild(btn);
});

// Placeholder for layers
let layers = [];
</script>

</body>
</html>
<script>
// ---------------- FULL TYLER ROAD NETWORK ----------------

// Define segments: name, points, free-flow speed, departments
const roadNetwork = [
  // Major arterials
// Broadway Ave North
  { corridor:"Broadway Ave N", geom:[[32.3750,-95.3000],[32.3745,-95.3000]], free:45, speed:45, departments:["Traffic","Police"], confidence:0.8 },
  { corridor:"Broadway Ave N", geom:[[32.3745,-95.3000],[32.3740,-95.3000]], free:45, speed:45, departments:["Traffic","Police"], confidence:0.8 },
  { corridor:"Broadway Ave N", geom:[[32.3740,-95.3000],[32.3735,-95.3000]], free:45, speed:45, departments:["Traffic","Police"], confidence:0.8 },
  { corridor:"Broadway Ave N", geom:[[32.3735,-95.3000],[32.3730,-95.3000]], free:45, speed:45, departments:["Traffic","Police"], confidence:0.8 },

  // Loop 323 North
  { corridor:"Loop 323 N", geom:[[32.3800,-95.3200],[32.3800,-95.3150]], free:50, speed:50, departments:["Traffic","Engineering"], confidence:0.85 },
  { corridor:"Loop 323 N", geom:[[32.3800,-95.3150],[32.3800,-95.3100]], free:50, speed:50, departments:["Traffic","Engineering"], confidence:0.85 },
  { corridor:"Loop 323 N", geom:[[32.3800,-95.3100],[32.3800,-95.3050]], free:50, speed:50, departments:["Traffic","Engineering"], confidence:0.85 },

  // SH-31 East
  { corridor:"SH-31", geom:[[32.3700,-95.3400],[32.3700,-95.3350]], free:55, speed:55, departments:["Traffic","Engineering"], confidence:0.9 },
  { corridor:"SH-31", geom:[[32.3700,-95.3350],[32.3700,-95.3300]], free:55, speed:55, departments:["Traffic","Engineering"], confidence:0.9 },
  { corridor:"SH-31", geom:[[32.3700,-95.3300],[32.3700,-95.3250]], free:55, speed:55, departments:["Traffic","Engineering"], confidence:0.9 },

  // Cumberland Rd (curved)
  { corridor:"Cumberland Rd", geom:[[32.3600,-95.3100],[32.3595,-95.3095]], free:40, speed:40, departments:["Traffic","Streets"], confidence:0.75 },
  { corridor:"Cumberland Rd", geom:[[32.3595,-95.3095],[32.3590,-95.3090]], free:40, speed:40, departments:["Traffic","Streets"], confidence:0.75 },
  { corridor:"Cumberland Rd", geom:[[32.3590,-95.3090],[32.3585,-95.3085]], free:40, speed:40, departments:["Traffic","Streets"], confidence:0.75 },

  // Fifth Ave
  { corridor:"Fifth Ave", geom:[[32.3550,-95.3000],[32.3550,-95.2950]], free:35, speed:35, departments:["Traffic","Police"], confidence:0.7 },
  { corridor:"Fifth Ave", geom:[[32.3550,-95.2950],[32.3550,-95.2900]], free:35, speed:35, departments:["Traffic","Police"], confidence:0.7 },

  // Sixth Ave
  { corridor:"Sixth Ave", geom:[[32.3540,-95.3000],[32.3540,-95.2950]], free:35, speed:35, departments:["Traffic","Police"], confidence:0.7 },
  { corridor:"Sixth Ave", geom:[[32.3540,-95.2950],[32.3540,-95.2900]], free:35, speed:35, departments:["Traffic","Police"], confidence:0.7 },

  // Greenwood Rd
  { corridor:"Greenwood Rd", geom:[[32.3600,-95.3050],[32.3580,-95.3050]], free:40, speed:40, departments:["Traffic","Streets"], confidence:0.75 },

  // Loop 323 South
  { corridor:"Loop 323 S", geom:[[32.3450,-95.3200],[32.3450,-95.3150]], free:50, speed:50, departments:["Traffic","Engineering"], confidence:0.85 },
  { corridor:"Loop 323 S", geom:[[32.3450,-95.3150],[32.3450,-95.3100]], free:50, speed:50, departments:["Traffic","Engineering"], confidence:0.85 },

  // East Erwin St
  { corridor:"East Erwin St", geom:[[32.3500,-95.3000],[32.3500,-95.2950]], free:40, speed:40, departments:["Traffic","Streets"], confidence:0.8 },

  // West Erwin St
  { corridor:"West Erwin St", geom:[[32.3550,-95.3050],[32.3550,-95.3000]], free:40, speed:40, departments:["Traffic","Streets"], confidence:0.8 },

  // Loop 323 West
  { corridor:"Loop 323 W", geom:[[32.3700,-95.3200],[32.3700,-95.3250]], free:50, speed:50, departments:["Traffic","Engineering"], confidence:0.85 },
  { corridor:"Loop 323 W", geom:[[32.3700,-95.3250],[32.3700,-95.3300]], free:50, speed:50, departments:["Traffic","Engineering"], confidence:0.85 },

  // South Broadway Ave
  { corridor:"Broadway Ave S", geom:[[32.3450,-95.3000],[32.3460,-95.3000]], free:45, speed:45, departments:["Traffic","Police"], confidence:0.8 },
  { corridor:"Broadway Ave S", geom:[[32.3460,-95.3000],[32.3470,-95.3000]], free:45, speed:45, departments:["Traffic","Police"], confidence:0.8 },

  // Loop 323 Connector
  { corridor:"Loop 323 Connector", geom:[[32.3550,-95.3100],[32.3550,-95.3050]], free:50, speed:50, departments:["Traffic","Engineering"], confidence:0.85 },

  // Additional downtown connector
  { corridor:"Liberty Rd", geom:[[32.3560,-95.3000],[32.3550,-95.3000]], free:35, speed:35, departments:["Traffic","Streets"], confidence:0.7 },

  // Bonus major road
  { corridor:"Tyler St", geom:[[32.3580,-95.3050],[32.3560,-95.3030]], free:40, speed:40, departments:["Traffic","Police"], confidence:0.75 }

// Build segment objects with upstream/downstream connectivity
let segments = [];
roadNetwork.forEach(r => {
  for (let i = 0; i < r.points.length - 1; i++) {
    segments.push({
      corridor: r.name,
      geom: [r.points[i], r.points[i + 1]],
      free: r.free,
      speed: r.free,
      volume: Math.random(),
      shock: 0,
      departments: r.departments,
      confidence: 0.6 + Math.random()*0.35,
      upstream: [], // filled later
      downstream: []
    });
  }
});

// Connect segments for traffic propagation (basic neighbor assignment)
segments.forEach((seg,i) => {
  for(let j=0;j<segments.length;j++){
    if(i!==j){
      // if end of this segment matches start of another, it's downstream
      const end = seg.geom[seg.geom.length-1];
      const start = segments[j].geom[0];
      if(Math.abs(end[0]-start[0])<0.0005 && Math.abs(end[1]-start[1])<0.0005){
        seg.downstream.push(segments[j]);
        segments[j].upstream.push(seg);
      }
    }
  }
});

// Debug: draw all segments faintly
segments.forEach(seg=>{
  L.polyline(seg.geom,{color:'#888',weight:2,opacity:0.3}).addTo(map);
});

console.log("Full Tyler road network initialized with " + segments.length + " segments.");
</script>
<script>
// ---------------- DYNAMIC TRAFFIC SIMULATION ----------------

// Clear previous congestion layers
function clearLayers() {
  layers.forEach(l => map.removeLayer(l));
  layers = [];
}

// Update traffic for one cycle
function simulateTraffic() {
  clearLayers();
  let reports = [];
  let totalSpeed = 0, congested = 0, alerts = 0;

  segments.forEach(seg => {
    // Base traffic demand
    let demand = 0.3 + Math.random() * 0.5;

    // Apply upstream congestion
    let upstreamImpact = 0;
    seg.upstream.forEach(up => {
      if (up.speed < 20) upstreamImpact += 5;
    });

    // Random incidents (will add proper simulation later)
    let randomShock = Math.random() > 0.98 ? 15 : 0;

    // Apply congestion/shock
    seg.shock = seg.shock * 0.75 + upstreamImpact + randomShock;

    // Compute new speed
    seg.speed = Math.max(5, seg.free - seg.shock - demand*10);
    totalSpeed += seg.speed;

    // Determine congestion level
    let level = seg.speed < 15 ? 2 : seg.speed < 25 ? 1 : 0;
    if (level > 0) { congested++; alerts++; }

    // Color coding
    let color = level === 2 ? "#ff4d4d" : level === 1 ? "#ffb703" : "#2ec4b6";
    let weight = level === 2 ? 8 : level === 1 ? 6 : 3;

    // Draw segment on map
    layers.push(L.polyline(seg.geom, { color, weight, opacity:0.95 }).addTo(map));

    // Generate situation report
    if(level > 0){
      reports.push({
        text: `${seg.corridor}: ${level === 2 ? "Heavy" : "Moderate"} congestion. Speed ${seg.speed.toFixed(0)} mph.`,
        confidence: seg.confidence
      });
    }
  });

  // Update KPIs
  document.getElementById("avgSpeed").innerText = (totalSpeed / segments.length).toFixed(1) + " mph";
  document.getElementById("congested").innerText = congested;
  document.getElementById("tti").innerText = (1 + congested / segments.length).toFixed(2);
  document.getElementById("alerts").innerText = alerts;

  // Update situation reports
  const reportEl = document.getElementById("reports");
  reportEl.innerHTML = "";
  reports.slice(0, 12).forEach(r => {
    reportEl.innerHTML += `<div class="report"><b>Waze Traffic Alert</b><br>${r.text}<br><small>Confidence: ${(r.confidence*100).toFixed(0)}%</small></div>`;
  });
}

// ---------------- CONTINUOUS SIMULATION ----------------
simulateTraffic(); // initial call
setInterval(simulateTraffic, 6000); // update every 6 seconds
</script>
<script>
// ---------------- WEATHER & INCIDENT SIMULATION ----------------

// Weather zones (center + radius in degrees, intensity affects speed)
let weatherZones = [
  { center:[32.355,-95.310], radius:0.012, intensity:8, type:"Heavy Rain" },
  { center:[32.340,-95.330], radius:0.015, intensity:6, type:"Wind Gusts" },
  { center:[32.345,-95.290], radius:0.010, intensity:10, type:"Thunderstorm" }
];

// Draw weather zones on map
weatherZones.forEach(zone=>{
  L.circle(zone.center,{
    color:'#4dabf7',
    fillColor:'#4dabf7',
    fillOpacity:0.2,
    radius: zone.radius*10000
  }).addTo(map);
});

// Incident array
let incidents = [];

// Spawn a random incident on a segment
function spawnIncident() {
  const seg = segments[Math.floor(Math.random()*segments.length)];
  const types = ["Accident","Disabled Vehicle","Construction"];
  const type = types[Math.floor(Math.random()*types.length)];
  incidents.push({
    segment: seg,
    type: type,
    active: true,
    timer: 3 + Math.floor(Math.random()*4) // lasts 3-6 cycles
  });
}

// ---------------- SIMULATION WITH WEATHER & INCIDENTS ----------------
function simulateTrafficWithEvents() {
  // Clear previous map lines
  clearLayers();

  let reports = [];
  let totalSpeed = 0, congested = 0, alerts = 0;

  segments.forEach(seg=>{
    // Base demand
    let demand = 0.3 + Math.random()*0.5;

    // Upstream congestion
    let upstreamImpact = 0;
    seg.upstream.forEach(up=>{
      if(up.speed < 20) upstreamImpact += 5;
    });

    // Random new incidents
    if(Math.random() > 0.97) spawnIncident();

    // Incident impact
    let incidentImpact = 0;
    incidents.forEach(inc=>{
      if(inc.segment === seg && inc.active) incidentImpact += 15;
    });

    // Weather impact
    let weatherImpact = 0;
    weatherZones.forEach(zone=>{
      const lat = (seg.geom[0][0]+seg.geom[1][0])/2;
      const lng = (seg.geom[0][1]+seg.geom[1][1])/2;
      const dist = Math.sqrt((lat-zone.center[0])**2 + (lng-zone.center[1])**2);
      if(dist < zone.radius) weatherImpact += zone.intensity;
    });

    // Apply previous shock decay
    seg.shock = seg.shock * 0.75 + upstreamImpact + incidentImpact + weatherImpact;

    // Compute speed
    seg.speed = Math.max(5, seg.free - seg.shock - demand*10);
    totalSpeed += seg.speed;

    // Determine congestion level
    let level = seg.speed < 15 ? 2 : seg.speed < 25 ? 1 : 0;
    if(level > 0){ congested++; alerts++; }

    // Color coding
    let color = level === 2 ? "#ff4d4d" : level === 1 ? "#ffb703" : "#2ec4b6";
    let weight = level === 2 ? 8 : level === 1 ? 6 : 3;

    layers.push(L.polyline(seg.geom,{color,weight,opacity:0.95}).addTo(map));

    // Generate report
    if(level > 0){
      let causes = [];
      if(weatherImpact>0) causes.push("Weather: "+weatherZones.find(z=>Math.sqrt(((seg.geom[0][0]+seg.geom[1][0])/2-z.center[0])**2+((seg.geom[0][1]+seg.geom[1][1])/2-z.center[1])**2)<z.radius).type);
      if(incidentImpact>0) causes.push("Incident");
      if(causes.length===0) causes.push("Demand/Downstream Constraint");

      reports.push({
        text:`${seg.corridor}: ${level===2?"Heavy":"Moderate"} congestion. Speed ${seg.speed.toFixed(0)} mph. Cause: ${causes.join(", ")}.`,
        confidence: seg.confidence
      });
    }
  });

  // Update incident timers
  incidents.forEach(inc=>{
    if(inc.active){
      inc.timer -= 1;
      if(inc.timer <=0) inc.active=false;
    }
  });

  // Update KPIs
  document.getElementById("avgSpeed").innerText = (totalSpeed/segments.length).toFixed(1)+" mph";
  document.getElementById("congested").innerText = congested;
  document.getElementById("tti").innerText = (1+congested/segments.length).toFixed(2);
  document.getElementById("alerts").innerText = alerts;

  // Update reports
  const reportEl = document.getElementById("reports");
  reportEl.innerHTML = "";
  reports.slice(0,12).forEach(r=>{
    reportEl.innerHTML += `<div class="report"><b>Waze Traffic Alert</b><br>${r.text}<br><small>Confidence: ${(r.confidence*100).toFixed(0)}%</small></div>`;
  });
}

// ---------------- RUN SIMULATION ----------------
simulateTrafficWithEvents();
setInterval(simulateTrafficWithEvents, 6000);
</script>
<script>
// ---------------- DEPARTMENTAL FILTER FUNCTION ----------------
function filterByDepartment(dept) {
  clearLayers(); // remove all previous segment lines
  let reports = [];
  let totalSpeed = 0, congested = 0, alerts = 0;

  segments.forEach(seg => {
    // If the department filter is active, skip irrelevant segments
    if(dept !== "All" && !seg.departments.includes(dept)) return;

    // Compute congestion level
    let level = seg.speed < 15 ? 2 : seg.speed < 25 ? 1 : 0;
    if(level > 0) { congested++; alerts++; }

    totalSpeed += seg.speed;

    // Color coding for congestion
    let color = level === 2 ? "#ff4d4d" : level === 1 ? "#ffb703" : "#2ec4b6";
    let weight = level === 2 ? 8 : level === 1 ? 6 : 3;

    // Draw segment
    layers.push(L.polyline(seg.geom, {color, weight, opacity:0.95}).addTo(map));

    // Add to report if congested
    if(level > 0){
      reports.push({
        text: `${seg.corridor} [${dept}]: ${level===2?"Heavy":"Moderate"} congestion. Speed ${seg.speed.toFixed(0)} mph.`,
        confidence: seg.confidence
      });
    }
  });

  // Update KPIs
  document.getElementById("avgSpeed").innerText = (totalSpeed / segments.length).toFixed(1) + " mph";
  document.getElementById("congested").innerText = congested;
  document.getElementById("tti").innerText = (1 + congested / segments.length).toFixed(2);
  document.getElementById("alerts").innerText = alerts;

  // Update situation reports
  const reportEl = document.getElementById("reports");
  reportEl.innerHTML = "";
  reports.slice(0,12).forEach(r=>{
    reportEl.innerHTML += `<div class="report"><b>Department Filtered</b><br>${r.text}<br><small>Confidence: ${(r.confidence*100).toFixed(0)}%</small></div>`;
  });
}

// ---------------- DEPARTMENT BUTTON HOOKS ----------------
const deptDiv = document.getElementById("departmentButtons");
deptDiv.innerHTML = ""; // clear previous placeholder

const departments = ["All","Police","Fire","Traffic","Streets","Engineering"];
departments.forEach(dept => {
  const btn = document.createElement('button');
  btn.innerText = dept;
  btn.onclick = () => {
    filterByDepartment(dept);
  };
  deptDiv.appendChild(btn);
});
</script>
<script>
// ---------------- PREDICTIVE CONGESTION ----------------
function predictNextCycle() {
  segments.forEach(seg=>{
    // Basic forecast: if upstream is slow, segment likely slows
    let upstreamAvg = 0;
    seg.upstream.forEach(up=>upstreamAvg += up.speed);
    if(seg.upstream.length>0) upstreamAvg /= seg.upstream.length;
    
    // Predicted speed decreases if upstream is congested
    seg.predictedSpeed = Math.max(5, seg.speed - (Math.max(0,20-upstreamAvg)/2));
  });
}

// ---------------- INTERACTIVE POPUPS ----------------
function addSegmentPopups() {
  clearLayers();
  segments.forEach(seg=>{
    // Determine congestion level
    let level = seg.speed < 15 ? 2 : seg.speed < 25 ? 1 : 0;
    let color = level===2?"#ff4d4d":level===1?"#ffb703":"#2ec4b6";
    let weight = level===2?8:level===1?6:3;

    const poly = L.polyline(seg.geom,{color,weight,opacity:0.95}).addTo(map);

    // Build popup content
    let popupHTML = `<b>${seg.corridor}</b><br>
                     Current Speed: ${seg.speed.toFixed(1)} mph<br>
                     Predicted Speed: ${seg.predictedSpeed.toFixed(1)} mph<br>
                     Departments: ${seg.departments.join(", ")}<br>`;

    // Check active incidents
    const activeIncidents = incidents.filter(inc=>inc.segment===seg && inc.active);
    if(activeIncidents.length>0){
      popupHTML += `<b>Incidents:</b><br>`;
      activeIncidents.forEach(inc=>{
        popupHTML += `- ${inc.type}, Timer: ${inc.timer}<br>`;
      });
    }

    // Check weather impact
    const affectedWeather = weatherZones.filter(zone=>{
      const lat = (seg.geom[0][0]+seg.geom[1][0])/2;
      const lng = (seg.geom[0][1]+seg.geom[1][1])/2;
      return Math.sqrt((lat-zone.center[0])**2 + (lng-zone.center[1])**2)<zone.radius;
    });
    if(affectedWeather.length>0){
      popupHTML += `<b>Weather Impact:</b><br>`;
      affectedWeather.forEach(z=>popupHTML += `- ${z.type}, Intensity: ${z.intensity}<br>`);
    }

    poly.bindPopup(popupHTML);
    layers.push(poly);
  });
}

// ---------------- FULL SIMULATION STEP ----------------
function runFullSimulation() {
  simulateTrafficWithEvents();  // update speeds with traffic, incidents, weather
  predictNextCycle();            // calculate predicted speed for next cycle
  addSegmentPopups();            // render map with interactive popups
}

// Run continuously every 6 seconds
runFullSimulation();
setInterval(runFullSimulation,6000);
</script>
