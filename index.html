<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tyler, TX Traffic & Operations Simulation</title>
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    
    <style>
        :root {
            --bg-dark: #1a1a1d;
            --panel-bg: #252529;
            --text-main: #e0e0e0;
            --accent: #4a90e2;
            --danger: #e74c3c;
            --warning: #f1c40f;
            --success: #2ecc71;
            --header-height: 60px;
        }

        body, html { margin: 0; padding: 0; height: 100%; font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; background-color: var(--bg-dark); color: var(--text-main); overflow: hidden; }

        /* Layout */
        #app-container { display: flex; height: 100vh; flex-direction: column; }
        
        /* Header */
        header {
            height: var(--header-height);
            background-color: var(--panel-bg);
            border-bottom: 1px solid #333;
            display: flex;
            align-items: center;
            padding: 0 20px;
            justify-content: space-between;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            z-index: 1000;
        }

        .brand { font-size: 1.2rem; font-weight: 700; color: var(--accent); letter-spacing: 1px; }
        .brand span { color: #fff; }
        
        /* Filters */
        .controls { display: flex; gap: 10px; }
        .filter-btn {
            background: #333; border: 1px solid #444; color: #aaa;
            padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 0.85rem;
            transition: all 0.2s;
        }
        .filter-btn:hover { background: #444; }
        .filter-btn.active { background: var(--accent); color: white; border-color: var(--accent); }

        /* Main Content */
        #main-view { display: flex; flex: 1; position: relative; }

        /* Map */
        #map { flex: 1; background: #111; z-index: 1; }

        /* Side Panel (Reports) */
        #side-panel {
            width: 350px;
            background: var(--panel-bg);
            border-left: 1px solid #333;
            display: flex;
            flex-direction: column;
            box-shadow: -2px 0 10px rgba(0,0,0,0.5);
            z-index: 2;
        }

        .panel-header { padding: 15px; background: #2c2c30; border-bottom: 1px solid #333; font-weight: 600; display: flex; justify-content: space-between; }
        .live-indicator { color: var(--danger); font-size: 0.8rem; animation: pulse 1.5s infinite; }

        #feed-container { flex: 1; overflow-y: auto; padding: 10px; }
        
        /* Feed Items */
        .feed-item {
            background: #2e2e33; border-left: 4px solid #555;
            padding: 12px; margin-bottom: 10px; border-radius: 0 4px 4px 0;
            font-size: 0.9rem; transition: transform 0.2s;
        }
        .feed-item:hover { background: #35353a; transform: translateX(2px); }
        .feed-header { display: flex; justify-content: space-between; margin-bottom: 5px; font-size: 0.8rem; color: #888; }
        .feed-street { font-weight: bold; color: #fff; margin-bottom: 4px; }
        .feed-detail { font-size: 0.85rem; color: #ccc; }
        .feed-tags { margin-top: 8px; display: flex; gap: 5px; flex-wrap: wrap; }
        .tag { font-size: 0.7rem; padding: 2px 6px; border-radius: 3px; background: #444; color: #ccc; }
        
        /* Severity Colors */
        .sev-low { border-left-color: var(--success); }
        .sev-med { border-left-color: var(--warning); }
        .sev-high { border-left-color: var(--danger); }
        .sev-crit { border-left-color: #8e44ad; }

        /* Map Legend Overlay */
        .map-overlay {
            position: absolute; bottom: 20px; left: 20px;
            background: rgba(0,0,0,0.8); padding: 10px; border-radius: 5px;
            z-index: 1000; font-size: 0.8rem; pointer-events: none;
        }
        .legend-item { display: flex; align-items: center; margin-bottom: 4px; }
        .color-box { width: 12px; height: 12px; margin-right: 8px; border-radius: 2px; }

        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }
        
        /* Scrollbar */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #222; }
        ::-webkit-scrollbar-thumb { background: #444; border-radius: 3px; }
    </style>
</head>
<body>

<div id="app-container">
    <header>
        <div class="brand">TYLER<span>SIM</span> <small style="font-size:0.7em; opacity:0.6; font-weight:normal;">/ TRAFFIC OPS</small></div>
        <div class="controls">
            <button class="filter-btn active" onclick="toggleLayer('all')">All</button>
            <button class="filter-btn" onclick="toggleLayer('PD')">Police</button>
            <button class="filter-btn" onclick="toggleLayer('FIRE')">Fire</button>
            <button class="filter-btn" onclick="toggleLayer('ENG')">Engineering</button>
        </div>
    </header>

    <div id="main-view">
        <div id="map"></div>
        
        <div class="map-overlay">
            <div class="legend-item"><div class="color-box" style="background:#2ecc71"></div> Free Flow</div>
            <div class="legend-item"><div class="color-box" style="background:#f1c40f"></div> Moderate</div>
            <div class="legend-item"><div class="color-box" style="background:#e74c3c"></div> Heavy</div>
            <div class="legend-item"><div class="color-box" style="background:#8e44ad"></div> Gridlock</div>
            <div class="legend-item"><div class="color-box" style="background:rgba(52, 152, 219, 0.4); border:1px solid cyan"></div> NWS Weather</div>
        </div>

        <div id="side-panel">
            <div class="panel-header">
                <span>Live Intelligence</span>
                <span class="live-indicator">‚óè LIVE</span>
            </div>
            <div id="feed-container">
                </div>
        </div>
    </div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

<script>
    // --- 1. CONFIGURATION & STATE ---
    const TYLER_CENTER = [32.3513, -95.3011];
    const UPDATE_INTERVAL = 1500; // ms
    
    // Departments
    const DEPTS = ['PD', 'FIRE', 'TRAFFIC', 'ENG', 'STREETS'];
    
    // State
    let map;
    let roadLayers = [];
    let weatherLayers = [];
    let activeFilter = 'all';
    let weatherSystems = [];
    let simulationTick = 0;

    // --- 2. GEOMETRY GENERATION (PROCEDURAL TYLER) ---
    // We generate coordinates mathematically to ensure smooth connectivity and curves without external files.

    function generateCurvedPath(start, end, bendFactor, numPoints) {
        // Simple Quadratic Bezier-like approximation for smooth roads
        const points = [];
        const latDiff = end[0] - start[0];
        const lngDiff = end[1] - start[1];
        
        // Midpoint with offset
        const midX = (start[0] + end[0]) / 2 + (lngDiff * bendFactor);
        const midY = (start[1] + end[1]) / 2 - (latDiff * bendFactor);

        for (let i = 0; i <= numPoints; i++) {
            const t = i / numPoints;
            const lat = (1 - t) * (1 - t) * start[0] + 2 * (1 - t) * t * midX + t * t * end[0];
            const lng = (1 - t) * (1 - t) * start[1] + 2 * (1 - t) * t * midY + t * t * end[1];
            points.push([lat, lng]);
        }
        return points;
    }

    // Generate Loop 323 (Approximate Ring)
    function generateLoop323() {
        const segments = [];
        const radius = 0.045; // Approx degrees
        const center = TYLER_CENTER;
        const totalSegments = 36; 
        
        for (let i = 0; i < totalSegments; i++) {
            const angleStart = (i / totalSegments) * Math.PI * 2;
            const angleEnd = ((i + 1) / totalSegments) * Math.PI * 2;
            
            // Start Point
            const sLat = center[0] + radius * Math.cos(angleStart) * 0.85; // slightly flattened
            const sLng = center[1] + radius * Math.sin(angleStart);
            
            // End Point
            const eLat = center[0] + radius * Math.cos(angleEnd) * 0.85;
            const eLng = center[1] + radius * Math.sin(angleEnd);
            
            segments.push({
                name: "Loop 323",
                sector: getSectorName(angleStart),
                coords: [[sLat, sLng], [eLat, eLng]], // Leaflet handles straight lines between close points fine
                speedLimit: 50
            });
        }
        return segments;
    }

    function getSectorName(angle) {
        // Helper to name loop segments (SE Loop 323, NW Loop 323, etc)
        const deg = (angle * 180 / Math.PI + 360) % 360;
        if(deg >= 337 || deg < 22) return "E Loop 323";
        if(deg >= 22 && deg < 67) return "SE Loop 323";
        if(deg >= 67 && deg < 112) return "S Loop 323";
        if(deg >= 112 && deg < 157) return "SW Loop 323";
        if(deg >= 157 && deg < 202) return "W Loop 323";
        if(deg >= 202 && deg < 247) return "NW Loop 323";
        if(deg >= 247 && deg < 292) return "N Loop 323";
        return "NE Loop 323";
    }

    // Data Structure for Roads
    // We create major corridors by connecting key coordinates
    const roadDefinitions = [
        // Broadway (N/S)
        { name: "S Broadway Ave", start: [32.351, -95.301], end: [32.25, -95.305], speed: 45, curve: 0.0 },
        { name: "N Broadway Ave", start: [32.351, -95.301], end: [32.40, -95.298], speed: 40, curve: 0.01 },
        // SH-31 (E/W)
        { name: "W Front St (SH-31)", start: [32.351, -95.301], end: [32.348, -95.40], speed: 50, curve: -0.02 },
        { name: "E Front St (SH-31)", start: [32.351, -95.301], end: [32.352, -95.20], speed: 45, curve: 0.01 },
        // Beckham / Troup (SE Diagonal)
        { name: "S Beckham Ave", start: [32.353, -95.295], end: [32.330, -95.280], speed: 40, curve: 0.0 },
        { name: "Troup Hwy (110)", start: [32.330, -95.280], end: [32.26, -95.22], speed: 55, curve: 0.05 },
        // Gentry (NW)
        { name: "Gentry Pkwy", start: [32.355, -95.305], end: [32.39, -95.34], speed: 45, curve: -0.05 },
        // Erwin / 64 (E)
        { name: "E Erwin St", start: [32.351, -95.301], end: [32.349, -95.22], speed: 40, curve: 0.0 },
        // Old Jacksonville (S)
        { name: "Old Jacksonville Hwy", start: [32.32, -95.31], end: [32.24, -95.34], speed: 50, curve: 0.08 },
        // Palace (Connector)
        { name: "SSW Loop 323 Conn", start: [32.30, -95.33], end: [32.30, -95.27], speed: 40, curve: 0 }
    ];

    // --- 3. INITIALIZATION ---

    function initMap() {
        // Init Leaflet
        map = L.map('map', {
            center: TYLER_CENTER,
            zoom: 12,
            zoomControl: false,
            attributionControl: false
        });
        
        // CartoDB Dark Matter tiles for professional look
        L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
            maxZoom: 19
        }).addTo(map);

        L.control.zoom({ position: 'topright' }).addTo(map);

        // Generate Roads
        generateRoadNetwork();
        
        // Start Sim
        initWeather();
        updateSimulation();
        setInterval(updateSimulation, UPDATE_INTERVAL);
    }

    function generateRoadNetwork() {
        // 1. Add Loop 323 Segments
        const loopSegments = generateLoop323();
        loopSegments.forEach(seg => createRoadEntity(seg.name, seg.coords, seg.speedLimit));

        // 2. Add Spoke Roads (split into smaller segments for detail)
        roadDefinitions.forEach(def => {
            // Generate curved points
            const fullPath = generateCurvedPath(def.start, def.end, def.curve, 20); // 20 points per major road
            
            // Split into logic segments (approx every 2-3 points)
            for (let i = 0; i < fullPath.length - 1; i++) {
                const segStart = fullPath[i];
                const segEnd = fullPath[i+1];
                createRoadEntity(def.name, [segStart, segEnd], def.speed);
            }
        });
    }

    function createRoadEntity(name, coords, baseSpeed) {
        // Assign Departments based on location logic (simplified)
        const depts = assignDepartments(name);

        const roadObj = {
            id: Math.random().toString(36).substr(2, 9),
            name: name,
            coords: coords,
            baseSpeed: baseSpeed,
            currentSpeed: baseSpeed,
            departments: depts,
            congestion: 0, // 0 to 1
            polyline: null
        };

        // Create Leaflet Polyline
        const line = L.polyline(coords, {
            color: '#2ecc71', // Initial Green
            weight: 4,
            opacity: 0.8,
            lineCap: 'round'
        }).addTo(map);

        // Popup
        line.bindPopup(() => generatePopupContent(roadObj));
        
        // Event listeners
        line.on('mouseover', function(e) {
            this.setStyle({ weight: 7, opacity: 1 });
        });
        line.on('mouseout', function(e) {
            this.setStyle({ weight: 4, opacity: 0.8 });
        });

        roadObj.polyline = line;
        roadLayers.push(roadObj);
    }

    function assignDepartments(name) {
        const d = ['PD', 'TRAFFIC']; // Default
        if (name.includes('Loop')) d.push('ENG');
        if (name.includes('Broadway') || name.includes('Front')) d.push('FIRE');
        if (Math.random() > 0.7) d.push('STREETS');
        return d;
    }

    // --- 4. SIMULATION LOGIC ---

    function initWeather() {
        // Create 2-3 weather systems
        for(let i=0; i<3; i++) {
            createWeatherSystem();
        }
    }

    function createWeatherSystem() {
        const startLat = TYLER_CENTER[0] + (Math.random() - 0.5) * 0.15;
        const startLng = TYLER_CENTER[1] + (Math.random() - 0.5) * 0.15;
        
        const circle = L.circle([startLat, startLng], {
            color: 'cyan',
            fillColor: '#3498db',
            fillOpacity: 0.2,
            radius: 1500 + Math.random() * 2000,
            weight: 1
        }).addTo(map);

        weatherSystems.push({
            layer: circle,
            center: [startLat, startLng],
            drift: [(Math.random()-0.5)*0.002, (Math.random()-0.5)*0.002], // Move per tick
            intensity: Math.random()
        });
    }

    function updateSimulation() {
        simulationTick++;
        
        // 1. Move Weather
        updateWeather();

        // 2. Update Traffic Data
        roadLayers.forEach(road => {
            let speedFactor = 1.0;
            
            // Weather Impact
            if (isUnderWeather(road.coords[0])) {
                speedFactor -= 0.3; // 30% slower in rain
            }

            // Random Incident Flux
            if (Math.random() > 0.95) {
                // Occasional jam spike
                road.congestion = Math.min(1, road.congestion + 0.4);
            } else {
                // Natural recovery
                road.congestion = Math.max(0, road.congestion - 0.05);
            }

            // Calculate Speed
            const effSpeed = road.baseSpeed * speedFactor * (1 - road.congestion);
            road.currentSpeed = Math.max(5, effSpeed);
            
            // Update Visuals
            updateRoadColor(road);
        });

        // 3. Generate Reports (Waze Style)
        if (simulationTick % 5 === 0 && Math.random() > 0.4) {
            generateIncidentReport();
        }
    }

    function updateWeather() {
        weatherSystems.forEach(sys => {
            sys.center[0] += sys.drift[0];
            sys.center[1] += sys.drift[1];
            
            // Boundary check: Wrap around or bounce? Wrap for simplicity
            if (sys.center[0] > TYLER_CENTER[0] + 0.1) sys.center[0] -= 0.2;
            if (sys.center[0] < TYLER_CENTER[0] - 0.1) sys.center[0] += 0.2;
            if (sys.center[1] > TYLER_CENTER[1] + 0.1) sys.center[1] -= 0.2;
            if (sys.center[1] < TYLER_CENTER[1] - 0.1) sys.center[1] += 0.2;

            sys.layer.setLatLng(sys.center);
        });
    }

    function isUnderWeather(latlng) {
        // Simple distance check against first weather system for performance
        // In full prod, check all
        for(let w of weatherSystems) {
            const dist = map.distance(latlng, w.center);
            if(dist < w.layer.getRadius()) return true;
        }
        return false;
    }

    function updateRoadColor(road) {
        // Determine Color based on speed ratio
        const ratio = road.currentSpeed / road.baseSpeed;
        let color = '#2ecc71'; // Green
        
        if (ratio < 0.3) color = '#8e44ad'; // Gridlock (Purple/Black)
        else if (ratio < 0.5) color = '#e74c3c'; // Red
        else if (ratio < 0.8) color = '#f1c40f'; // Yellow
        
        // Visibility Check (Filter)
        if (activeFilter !== 'all' && !road.departments.includes(activeFilter)) {
            road.polyline.setStyle({ opacity: 0.1, color: '#555' });
        } else {
            road.polyline.setStyle({ color: color, opacity: 0.8 });
        }
    }

    // --- 5. UI & REPORTS ---

    const incidents = [
        "Stalled Vehicle", "Minor Accident", "Debris on Road", "Signal Malfunction", 
        "Heavy Congestion", "Pothole Reported", "Police Activity", "Flooding"
    ];

    function generateIncidentReport() {
        // Pick a random road that is congested
        const congestedRoads = roadLayers.filter(r => r.congestion > 0.3);
        if (congestedRoads.length === 0) return;

        const road = congestedRoads[Math.floor(Math.random() * congestedRoads.length)];
        const type = incidents[Math.floor(Math.random() * incidents.length)];
        const confidence = Math.floor(Math.random() * 20) + 80; // 80-100%
        
        let severity = 'low';
        if (road.congestion > 0.5) severity = 'med';
        if (road.congestion > 0.8) severity = 'high';

        // Add to Feed
        const feed = document.getElementById('feed-container');
        const item = document.createElement('div');
        item.className = `feed-item sev-${severity}`;
        
        const time = new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
        
        // Tags
        let tagsHtml = '';
        road.departments.forEach(d => {
            tagsHtml += `<span class="tag">${d}</span>`;
        });

        item.innerHTML = `
            <div class="feed-header">
                <span>${time}</span>
                <span>${confidence}% Conf</span>
            </div>
            <div class="feed-street">${road.name}</div>
            <div class="feed-detail">${type} - Speed: ${Math.round(road.currentSpeed)} mph</div>
            <div class="feed-tags">${tagsHtml}</div>
        `;

        feed.insertBefore(item, feed.firstChild);

        // Keep list clean
        if (feed.children.length > 20) {
            feed.removeChild(feed.lastChild);
        }
    }

    function generatePopupContent(road) {
        return `
            <div style="font-family: sans-serif; min-width: 150px;">
                <h3 style="margin:0 0 5px 0; font-size:16px;">${road.name}</h3>
                <hr style="border:0; border-top:1px solid #ccc; margin: 5px 0;">
                <div><strong>Status:</strong> ${road.congestion > 0.5 ? '<span style="color:red">Congested</span>' : '<span style="color:green">Flowing</span>'}</div>
                <div><strong>Speed:</strong> ${Math.round(road.currentSpeed)} / ${road.baseSpeed} mph</div>
                <div style="margin-top:5px;"><strong>Jurisdiction:</strong><br> ${road.departments.join(', ')}</div>
            </div>
        `;
    }

    // Filter Logic
    window.toggleLayer = function(dept) {
        activeFilter = dept;
        
        // Update Buttons
        document.querySelectorAll('.filter-btn').forEach(b => {
            if(b.textContent.toUpperCase().includes(dept) || (dept==='all' && b.textContent === 'All')) {
                b.classList.add('active');
            } else {
                b.classList.remove('active');
            }
        });

        // Force visual update
        roadLayers.forEach(r => updateRoadColor(r));
    }

    // Init
    initMap();

</script>
</body>
</html>
